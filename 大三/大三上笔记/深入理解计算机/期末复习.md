## 第一章

### 程序的编译过程

1. 源程序进行预处理，输出处理后的源程序
2. 处理后的源程序进行编译器编译，输出汇编程序
3. 汇编程序进行汇编，输出二进制文件
4. 和外部库连接，输出可执行目标程序



系统硬件的构成



操作系统过程



抽象机制



进程和线程

进程：对正在运行程序的抽象
用户角度：独占系统
系统角度：多个任务并发执行
线程：进程的一个执行单元，一个进程中可以包含多个线程



Amadal定律：多处改变怎么计算



### 并行和并发

并发：指多个任务在同一个时间段内快速地轮换执行

* 线程级并发
  * 单处理器系统：多个任务轮流与系统交互
  * 多处理器系统：每个处理器完成一个任务。多个任务可以并行
    * 多核处理器：通过增加 CPU 的核心数，可以提高系统的性能
    * 超线程：同时多线程，允许cpu同时执行多个控制流

并行：是指多个任务同时进行，是真正意义上的同时执行

* 指令级并行：处理器可以同时执行多条指令的属性

## 第二章

### 字节序和对齐

大端小端字节序：字节存储，字访问。存储数据大于字节，需要存放顺序

对齐：数据存放地址的要求，按照数据类型大小的整数倍来进行存储

* 保证存储访问的效率，否则访问双字数据有可能出现多次内存访问

### 位运算和逻辑运算

位运算：

* 非：就是每一位与进制取反
  * 二进制：~1=0
  * 十六进制：~4=B
* 和：都为1则1，否则为0
  * 二进制：11&10=10
  * 十六进制：69&55=41
* 或运算：对应位置只要有1就为1

逻辑运算：

* 

### 整数表示

* 表示：源码，反码，补码，移码
* 四则运算
  * 乘法---移位运算和加法运算代替
  * 除法---数据最后的舍入，加入偏置值

### 浮点数表示

* 基本格式：符号，阶码，尾数
  * 移码表示阶码：8位阶码---指数+127
  * 尾数用原码表示(单精度、双精度)

> bias=$2^{n-1}-1$

#### 规格化

E=e-bias

M=1+f

#### 非规格化

阶码全为0 ：E=1-bias，M=f

阶码全为1 ：f全为0则无穷，否则Nan

#### 舍入

向上：向大于x的值舍入

向下：向小于x的值舍入

向零：向接近零的摄舍入

向偶：向最接近的值舍入，1.5则向偶数舍入



## 第三章

### 寄存器功能

| 寄存器地址 | 功能             |
| ---------- | ---------------- |
| %rax       | 存放返回值       |
| %rbx       | 被调用者保存地址 |
| %rcx       | 存放第四个参数   |
| %rdx       | 存放第三个参数   |
| %rsi       | 存放第二个参数   |
| %rdi       | 存放第一个参数   |
| %rbp       | 被调用者保存     |
| %rsp       | 存放栈指针       |
| %r8--%r9   | 第5-6个参数      |
| %r10-%r11  | 调用者保存       |
| %r12--%r15 | 被调用者保存     |

>调用者保存：
>函数A在调用函数B之前，提前保存寄存器rbx的内容，执行完函数B之后，再恢复寄存器rbx原来存储的内容
>
>被调用者保存：
>函数B在使用寄存器rbx之前，先保存寄存器rbx的值，在函数B返回之前，先恢复寄存器rbx原来存储的内容

### 操作数与寻址

操作数类型：

* 立即数：用\$表示，传送指令：movq \$0x4,%rax
* 寄存器：直接调用寄存器，传送指令：movq %rax,%rdx
* 存储器：使用括号将寄存器括起来表示值，传送指令：movq (%rax),%rdx

### 各类指令功能

> b：1； w：2； l：4； q：8；

#### 传送类指令

把数据从源位置复制到目的位置mov包括movb,movw,movl,movq

出栈入栈指令：堆栈也可以完成数据传送的工作，它是遵循先进后出规则的一个内存区域。它的地址向下增长，栈顶元素的地址最小

#### 运算类指令

| 描述         | 指令     | 效果         |
| ------------ | -------- | ------------ |
| 加载有效地址 | leaq S,D | D<--&S       |
| 加1          | INC D    | D<--D+1      |
| 减1          | DEC D    | D<--D-1      |
| 取负         | NEG D    | D<---D       |
| 取反         | NOT D    | D<--~D       |
| 加法         | ADD S,D  | D<--D+S      |
| 减法         | SUB S,D  | D<--D-s      |
| 乘法         | IMUL S,D | D<--D*S      |
| 异或         | XOR S,D  | D<--D^S      |
| 或           | OR S,D   | D<--D\|S     |
| 与           | AND S,D  | D<--D&S      |
| 算数左移     | SAL k,D  | D<--D<<k     |
| 逻辑左移     | SHL k,D  | D<--D<<k     |
| 算术右移     | SAR k,D  | D<--D$>>_A$k |
| 逻辑右移     | SHR k,D  | D<--D$>>_L$k |

加载有效地址：源操作数是地址表达式，但不直接引用内存，不敌操作数存放表达式形成的地址

一元操作：只有一个操作数，因此该数即是源操作数又是目的操作数，可以说寄存器也可以是内存地址

二元操作数：
第一个操作数是源操作数，可以是立即数、寄存器或者内存地址；
第二个操作数既是源操作数也是目的操作数， 可以是寄存器或者内存地址，但不能是立即数

移位操作：
左移指令SAL和SHL，二者的效果是一样的，都是在右边填零
右移指令包括算术右移和逻辑右移
算术右移算术右移需要填符号位
逻辑右移，逻辑右移需要填零

> 对于移位量k，可以是一个立即数，或者是放在寄存器cl中的数，对于移位指令只允许以特定的寄存器cl作为操作数，其他寄存器不行

#### 条件码

| 条件码 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| CF     | 进位标志,可以用来检查无符号数操作的溢出，产生进位置1         |
| ZF     | 零标志，当最近操作的结果等于零时,置1                         |
| SF     | 符号标志，当最近的操作结果小于零时，置1                      |
| OF     | 溢出标志，针对有符号数，最近的操作导致正溢出或者负溢出时，被置1 |

> Leaq对条件码不起作用

![](img\Set.png) 

#### 比较指令

| 描述 | 指令           | 基于         |
| ---- | -------------- | ------------ |
| 比较 | cmp $S_1,S_2$  | $S_2-S_1$    |
| 测试 | TEST $S_1,S_2$ | $S_1 \& S_2$ |

#### 跳转指令

将当前指令的执行从当前位置切换到新位置，可以直接进行或根据状态码状态

![](img\jmp.png)

#### 条件分支的实现

控制的条件转移：比较指令+跳转指令

数据的条件转移：

![](img\条件传说指令.png)

> 表达式的计算复杂度高时，不适合用条件传送

#### 循环

do-while

> 先执行do，在进行条件判断，满足则跳回goto循环起始位置

while

> 先跳，跳到条件判断，满足则再跳到do位置

for

> 将for的参数初始化在循环外赋值，限制条件放在while里，改写成while再进行

switch

> 先进性判断，然后跳转goto到对应的case中，否则跳转到default处，break即跳转到最后

#### 跳转表



### 过程



栈帧：

![](img\栈帧.png)

转移控制：函数P调用函数Q，把返回地址压入栈中，指明当函数Q执行结束返回时要从函数P的哪个位置继续执行，由call指令执行

Call指令：call label

* 返回地址压栈
* 跳转到label指示的地址

Ret指令：ret

* 弹出返回地址
* 转向返回地址

数据传递

> 如果一个函数的参数数量大于6，超出的部分就要通过栈来传递
>
> movq n*4(%rsp)，%rax

栈上的局部存储

> 当代码中对一个局部变量使用地址运算符‘&’时，需要在栈上为这个局部变量开辟相应的存储空间

寄存器的局部存储空间

当过程P调用Q时，P为调用者，Q为被调用者

调用者保存：调用者将临时值保存在自己的栈帧中
被调用者保存：被调用者在使用前将临时值保存在自己的栈帧中，返回时进行恢复

### 数组

数组T A\[L\]：

* 数据类型T和长度L
* 需要给数组分配连续空间大小为L*sizeof(T)字节
* 任何字节的指针都是8字节

嵌套数组T A\[R\]\[C\]：嵌套数组中行优先

* A是二维数组
* R是行数，C是列数
* T是A中元素的数据类型
* 数据连续空间大小为R\*C\*T字节
* 地址访问为：A+i\*(C\*T)+J\*T=A+(i\*C+j)\*K
  * 数组起始地址A，加上行起始地址，再加上列起始地址

定长数组和变长数组

### 结构体

结构：将不同类型的对象集中到一个对象中

结构体的所有组成部分存储在内存一段连续的区域中存放的顺序按照声明的顺序
指向结构体的指针是结构体第一个字节的地址

### 对齐

数据以数据类型的整数倍分配空间

结构体数据的对齐：

* 结构体内部：满足每个数据的对齐条件
* 整个结构体：结构体的对齐按照最长元素长度K来决定

### 缓冲区溢出

> 内存越界导致缓冲区溢出

解决溢出方法：

* 栈随机化：栈的位置在程序每次运行时都有变化
* 栈破坏检测：栈保护机制：在缓冲区与栈保存的状态值之间存储一个特殊值，这个特殊值被称作金丝雀值，这个数值是程序每次运行时随机产生的，在函数返回之前，检测金丝雀值是否被修改来判断是否遭受攻击
* 限制可执行代码区域

## 第四章

指令系统，也称指令集架构，包含机器所具有的全部指令, 它反映了计算机所拥有的基本功能。是编译器编写者和处理器设计人员的桥梁

* 复杂指令集CISC：冯诺依曼结构---Intel x86
* 精简指令集RISC：哈佛结构---arm，IBMpower

> 英特尔再CISC中增加翻译层引入RISC，RISC指令的扩充--指令条数、执行周期

### Y86指令集体系结构

#### 寄存器

寄存器有十五个：

| %rax | %rcx | %RDX | %RBX |
| ---- | ---- | ---- | ---- |
| %RSP | %RBP | %RSI | %RDI |
| %R8  | %R9  | %R10 | %R11 |
| %R12 | %R13 | %R14 |      |

寄存器%rsp作为栈指针
程序计数器PC保存当前正在执行指令的地址

#### 指令编码

![](img\指令编码.png)

![](img\指令编码2.png)

寄存器编码

![](img\指令编码3.png)

指令编码示例：

>指令`rmmovq %rsp,0x123456789abcd(%rdx)`对应的十六进制表示
>
>1.从指令编码表查找指令代码：rmmovq--40
>2.源操作数4(%rsp) 目的操作数2(%rdx)
>3.偏移量`cd ab 89 67 45 23 01 00`(小端位序)
>4.结果：`40 42 cd ab 89 67 45 23 01 00`

#### 异常

![](img\指令异常.png)

> 程序的状态码，描述了程序执行的总体状态。
> 当代码值为1时，表示程序正常执行，而其他三个代码表示程序发生了某种类型的异常

#### pop和push

push %rsp：返回结果总是0，说明压入堆栈的是rsp的原始值

pop %rsp：返回结果总是0xabcd，说明弹出堆栈的内存中的值

### 指令执行过程

指令处理步骤：

* 取指：根据PC从内存中去除将要执行的代码
* 译码：抽出操作码、寄存器、内存地址、立即数
  * 计算操作数有效地址：按照寻址方式计算
  * 取操作数：根据有效地址访问寄存器，内存去除操作数
* 运算：执行算术逻辑运算或转移指令相关的判断及运算
* 存结果：将运算结果和标志位存入相应的存储单元
* 形成下条指令地址：根据译码及其运算结果形成新的PC值并更新

指令执行硬件基础：

### 指令的顺序执行

微操作阶段

> 将微操作组织成所有指令都遵循的统一阶段序列
>
> 结构上简单一致，降低复杂度，提高软件利用率
> 有利于采用流水线方式实现

六阶段框架：取指-->解码-->执行-->访存-->写回-->更新PC

* 取指
  * 取出指令代码（icode）与指令功能（ifun）
  * 寄存器指示符rA和rB
  * 常数valC
  * 计算下一条指令的地址valP
* 译码
  * 从寄存器文件中读取操作数得到valA与valB
* 执行
  * ALU（算术逻辑单元）指明指令执行的操作，得到valE
* 访存
  * 见数据写入内存或者从内存读入数据
* 写回
  * 将结果写回到寄存器文件
* 更新
  * 将PC设置为下一条指令的地址

#### 指令执行的操作

整数运算及传送类指令

![](img\整数运算及传送类指令.png)

访存指令

![](img\访存指令.png)

栈操作指令

> 从不回读原则：处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。
> Push指令需要先减去栈顶指针再写数据，相当于从寄存器文件中读更新过的栈指针。

![](img\栈操作指令.png)

条件转移、过程调用：

![](img\条件转移.png)

#### 信号

>程序计数器、条件码寄存器、数据内存和寄存器文件都需要在统一时钟的控制下。
>只有执行运算指令时会改变CC的值，执行写存储单元的指令会写数据内存

提高处理及工作速度的途径

* 提高处理机的工作主频
* 使用RISK技术，缩短指令执行的平均时间
* 多条指令并行执行

### 流水线

并行：

* 空间并行性：即在一个处理机内设置多个独立的操作部件，并让这些操作部件并行工作
  这种处理机称为多操作部件处理机或超标量处理机
* 时间并行性：就是采用流水线技术。
  流水线技术是一种非常经济、对提高处理机的运算速度非常有效的技术

#### 流水线原理

指令执行衡量指标：

Throughput吞吐率：每秒执行指令数
Latency延时：执行一条指令所需要的时间

流水线的局限性：

* 操作划分不一致：时钟周期延长，吞吐率降低
* 流水线过深：寄存器延迟占比增加，时钟传播不同步

带反馈的流水线：以整条指令进行反馈周期--管道图

#### 流水线实现

划分阶段：

插入流水线的寄存器

* F：保存程序计数器的预测值
* D：保存最新取出的指令信息
* E：保存最新的译码指令和从寄存器文件读出的值的信息
* M：保存最新执行指令的结果，以及处理条件转移的分支条件和分支目标
* W：将反馈路径计算出来的值提供给寄存器文件，完成ret指令时向PC提高返回地址

预测下一个PC

* 出条件jxx和ret以外，取指阶段的计算就能确定下一个PC
* 对于call和jmp，下一个PC是valC，其他的是valP

选择PC，从三个值当中选择当前的取指地址：

* 上一条指令预测的PC
* 访存M阶段反馈的jxx分支预测错误的正确方向---顺序执行的地址
* 写回W阶段反馈的ret从堆栈中取出的返回地址

> 合并valA和ValP，后续计算中不会同时用到valA和ValP, 为了减少寄存器的状态和信号的数量, 在解码阶段合并为valA

### 流水线冒险

分类：

数据相关-局部相关

控制相关-全局相关

流水线冒险：相关导致流水线产生的错误



#### 数据冒险

> 同时在执行的多个指令之间，有数据依赖的情况

* 先写后读--数据依赖
* 先读后写--反依赖
* 写后再写--输出依赖

解决方法：

1. 暂停，流水线冒泡------发生在译码后的阶段

如果发现后面的执行，会对前面执行的指令有数据层面的依赖关系，则在进行译码的时候，将拿到对应指令所需要访问的寄存器和内存地址，此时，就可以判断出是否会出发数据冒险，如果出发数据冒险，就让整个流水线停顿一个或多个周期

> 在执行后面的操作步骤前，插入一个NOP操作，指定一个空操作，达到暂停的目的

2. 转发--需要在基本硬件结构额外增加数据连接和控制逻辑

将某个流水线阶段的中间结果向前传递到前面的阶段，且被前递的数据直接参与前面阶段中的操作

转发源：
写回阶段从寄存器读出-W_valE，
访存阶段从寄存器读出M_valE，
执行阶段的输出e_valE，
从访存阶段中读出的值m_valE，
写回阶段还没写入的值W_valM

转发目的：valA和valB



3. 加载使用数据冒险：内存读在流水线发生的比较晚，不能单纯用转发解决

将暂停和转发结合起来，以此来避免load-use数据冒险
暂停的方法叫做加载互锁--会降低流水线的吞吐量

> 从内存中读出一个值的指令和一条使用该值的指令之间必须暂停一个周期

#### <span style="color:red">控制冒险</span>

> 由于根据当前取指阶段的指令无法及时获得下一条指令地址所引起的
> 造成的主要原因是ret指令和条件转移指令

解决方法：

1. 停顿---等目标地址计算出来之后，再取新的指令
2. 分支预测

静态：

* 认定分支一定执行：遇到分支指令之后，先正常的去取指令，如果分支不发生，则流水线正常运行，如果发生跳转，则冲刷掉多取的两条指令
* 认定分支一定不执行：

动态：

*  分支预测缓冲区：将前面指令的执行结果与转向地址保存，遇到相同指令直接和缓冲区粗放你的指令对比，相同则跳转
* 分支历史表：使用表格记录跳转信息[1为跳转，2为不跳转]
  * 饱和计数法：用2bit记录信息：11和10跳转，00和01不跳转

#### 标量流水线与超标量

标量流水线处理器：每周期获取一条指令，顺序发射、顺序执行，且每周期最多执行一条指令

超标量：指 CPU 在一个时钟周期内获取、执行和提交多条指令。
多条指令之间有些可以并行执行、有些存在依赖关系，乱序执行可以在不影响程序功能的前提下，重新安排指令的执行顺序，让存在依赖关系的指令处于等待区，其他不相关的指令可以提前执行

> 乱序执行中需要进行分支预测，提前执行后续的指令
> 分支预测成功可以大幅度提高指令执行的效率

#### 预测错误分支处理

流水线往译码和执行阶段中插入气泡bubble，取消两条目标指令，同时还取出跳转后面的指令

#### 流水线控制逻辑

特殊控制情况的处理：

* ret: 暂停后续指令, 直至ret指令到达写回阶段
* load/use: 暂停后续指令, 直至load指令到达访存阶段
* jxx预测错误: 排除后续指令, 直至jxx指令到达访存阶段
* 异常：需要禁止异常指令后面的指令更新程序员可见的状态，在异常指令到达写回阶段时停止执行

特殊控制条件（冒险的触发条件）

## 第五章

### 局部性

空间局部性

时间局部性

### 层次结构

CPU开始---逐层向下

## cache

* 作用，引入目的
* 地址映像---三个
  * 数据访问过程
* 一致性
* 性能指标，影响命中率因素

## 虚拟存储

* 建立独立地址空间，给每个进程
* 逻辑地址和物理地址的区分
* 从虚拟--物理的过程
* 页表-查找速度慢-多级页表
* TLB
* TLB的结构，cache结构--求

## 第八章

### 异常类型

### 处理异常

系统调用-故障的使用

### 进程上下文切换

### 用户模式和核心模式

### 上下文切换模式