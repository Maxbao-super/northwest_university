# 存储器

## 存储器概述

### 随机访问存储器RAM

#### 静态随机访问存储器SRAM

特点：

* 速度快，接近CPU
* 只要通电，就能保持内部存储的数据
* 对干扰不敏感，不需要刷新
* 同样面积的芯片容量较小
* 价格高
* 一般用于构成cache

#### 动态随机访问存储器DRAM

特点：

* 速度比SRAM慢，容量比SRAM更大
* 对干扰敏感，会产生漏电，需要刷新
* 异步方式，随时响应控制输入的变化

增强的DRAM：

* 同步动态随机存取内存SDRAM：
  * SDRAM有一个同步接口，在响应控制输入前会等待一个时钟信号，这样就能和计算机的系统总线同步，实现更为复杂的操作模式，更高的速率
  * SDRAM在一个时钟周期内只传输一次数据，它是在时钟上升期进行数据传输
* 双倍速率同步动态随机存储器DDR SDRAM：
  * DDR是一个时钟周期内可传输两次数据，也就是在时钟的上升期和下降期各传输一次数据

### 内存模块

DRAM被封装在内存模块中，多个内存模块连接到内存控制器上，聚合成主存

> ![](img\内存模块.png)
>
> 上图中一个内存模块由8个64bit的$8M×8$的Dram构成，每个超单元（相当于位串的升级）存储主存的一个字节
>
> 地址为（i,j）的8个超单元构成字节地址A的64位字
>
> 读取A，需要将A翻译成（i,j）,再由内存模块将（i,j）广播给DRAM，然后DRAM输出内容

### 只读存储器ROM

**特点**：掉电不影响存储的数据，从只写一次发展到可多次写

**代表**：

* PROM：可编程ROM，只能被写一次

* EPROM：可擦写可编程，

* EEPROM：电子可擦除。

* Flash memory：基于EEPROM，代表U盘，存储卡，固态硬盘

* NOR Flash存储器（在芯片内执行，因此应用程序可以直接在Flash中运行，而不必读入系统RAM）

* NAND Flash存储器（存储容量更大，擦写速度更快）

### 磁盘存储器

特点：

* 容量大

* 速度较慢
* 每位价格较低

#### 机械磁盘

扇区访问时间：$T_{access}=T_{seek}+T_{rotation}+T_{transfer}$（寻道时间+旋转时间+传送时间）

#### 固态硬盘

### 程序的局部性

**局部性**：程序将要引用的数据或者指令在地址上邻近或者就是正在访问的地方

**时间局部性**：当前引用的内容很可能在不远的将来再次被访问

**空间局部性**：即将访问的内容与当前访问的内容在地址上是邻近的

### 存储设备的机械特性

机械特性：容量越大，速度越慢，位价格越低；速度越快，容量越小，位价格越高

由于程序的局部性，程序更频繁的访问某一层次上的存储设备，因此下层的设备可以更慢速一些，容量可以更大，每位价格更低。因此将特性不同的存储设备结合起来刚好可以满足程序局部性的特征，形成存储体系。

### 存储器层次结构

定义：两个和两个以上的速度、容量、价格各不相同的存储器用硬件、软件或软硬结合的方法连接起来的系统

**核心思想**：

* 缓存：层次结构中的每一层都缓存来自较低一层的数据块
* 缓存的工作模式：
  * 将缓存划分成相同数据块, 在相邻层之间传送块, 判断命中与不命中, 并处理它们, 由硬件、软件或两者结合的方式实现
  * 位于每个k层的速度更快、容量更小的设备作为k+1层的缓存

特点：速度接近最快的存储器；容量与容量最大的存储器相等或接近；单位价格接近于最便宜的存储器

![](img\存储器分层结构.png)

#### 主存-辅存

#### Cache-主存

#### 交叉访问存储器

### 关键问题

命中：当访问第k+1层的数据对象时，刚好该对象缓存在第k层

不命中：当访问第k+1层的数据对象时，该对象不在第k层缓存中

* 冷不命中(cold miss): 空缓存(冷缓存cold cache)造成不命中
* 冲突不命中(conflict miss): 限制性映像策略造成不命中
* 容量不命中(capacity miss): 缓存容量小于工作集造成不命中

替换：不命中时，需要从k+1层中将目标数据对象缓存到k层，如果k层满了，则替换掉现有缓存块

* 冲突：需要替换的现象
* 牺牲块：被替换掉的数据缓存块

## 高速缓存存储器Cache



### 典型结构

使用元组(S,E,B,m)表示：Set组，Cache Line行数，数据块包含字节，数据地址

每个cache被划分为多个Set，每个Set包含一个或多个CacheLine，每个CacheLine由有效位Valid，标记Tag和数据块Block组成

* 有效位：1个bit，表示当前存储的信息是否有效
* 标记
* 数据块：一小部分内存数据的副本，大小是B

cache容量$C=S*E*B$

### 地址映像分类

#### 直接映像

E=1：每一组Set只有一行Cache Line

1. 从L1.Cache中查询目标数据，命中则返回
2. 命中判断
   1. 组选择：根据组索引值
   2. 行匹配：每个Set只有一个Cache Line，对比Cache Line中的标记和目标地址的标记是否一致
   3. 字选择：从数据块的什么位置抽取数据，根据偏移量判断数据起始地址
3. 不命中：从下一层取出被请求的块，直接映射Set只有一行，就是直接替换即可

抖动：出现冲突不命中，导致Cache Line的替换

* 解决：数据填充

#### 组相联映射

$1<E\le{C/B}$：每个组Set至少有一个Cache Line

1. 从L1.Cache中查询目标数据，命中则返回
2. 命中判断
   1. 组选择：根据组索引值
   2. 行匹配：每个Set有多个Cache Line，遍历Set中每一行寻找有效位为1且标记为相同的cache line
   3. 字选择：从数据块的什么位置抽取数据，根据偏移量判断数据起始地址
3. 不命中：从下一层取出被请求的块，进行替换
   1. 优先替换有效位为0的行
   2. 使用替换策略：随即替换、LFU最不常使用、LRU最近最少

特点：

* 硬件实现很简单, 不需要相联访问存储器
* 访问速度也比较快, 实际上不做地址变换
* 块的冲突率较高

#### 全相联映射

S=1 E=C/B：只有一个组Set

* C表示cache容量，B表示数据块大小

全相联只有一个组，因此不需要组索引位进行组选择

全相联适合容量较小的高速缓存

### Cache一致性问题

* CPU写Cache的时候，修改了Cache的内容，但主存对应单元的内容与cache单元内容不一致；

* I/O设备读入数据到主存，修改了主存某单元的内容，而Cache中的内容还没有修改，也会使得cache与主存的单元内容不一致

通常**写分配和写回搭配**，**写不分配和写穿透搭配**

#### 写命中

写直达法write-through：写操作时，利用CPU与主存的通路，将块写入Cache中，也写入到主存

写回write-back：写操作时，信息只写入Cache,而不写入主存，仅当替换时，才将修改过的Cache内容块写回到主存中

#### 写不命中

写分配write-allocate：除了写入主存外，还将该块由主存调入Cache

写不分配no-write-allocate：只写入主存，不将该块从主存调入Cache

### 示例

> Intel高速缓存层次结构
>
> ![](img\intelArch.png)

### Cache的性能评价及影响因素

Cache的主要性能指标:

* 命中率(hit rate)、不命中率(miss rate): 命中、不命中的比率
* 命中时间(hit time): 从高速缓存读出一个字至cpu的时间
* 不命中惩罚(miss penalty): 由于不命中所需额外服务的时间

典型情况:

* L1的命中时间, 典型是1～2个时钟周期
* L1不命中从L2得到服务的惩罚, 典型是5～10个周期
* L1不命中从主存得到服务的惩罚, 典型是 25～100 个周期

影响Cache性能的主要因素:

* 存大小: 大的缓存能提高命中率, 但也会增加命中时间
* 大小: 块大有利于空间局部性, 块小却利于时间局部性
* 相联度、替换策略及写策略也会直接影响Cache的性能
