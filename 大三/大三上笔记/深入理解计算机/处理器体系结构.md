## 处理器体系结构

### 寄存器功能

| 寄存器地址 | 功能             |
| ---------- | ---------------- |
| %rax       | 存放返回值       |
| %rbx       | 被调用者保存地址 |
| %rcx       | 存放第四个参数   |
| %rdx       | 存放第三个参数   |
| %rsi       | 存放第二个参数   |
| %rdi       | 存放第一个参数   |
| %rbp       | 被调用者保存     |
| %rsp       | 存放栈指针       |
| %r8--%r9   | 第5-6个参数      |
| %r10-%r11  | 调用者保存       |
| %r12--%r15 | 被调用者保存     |

>调用者保存：
>函数A在调用函数B之前，提前保存寄存器rbx的内容，执行完函数B之后，再恢复寄存器rbx原来存储的内容
>
>被调用者保存：
>函数B在使用寄存器rbx之前，先保存寄存器rbx的值，在函数B返回之前，先恢复寄存器rbx原来存储的内容

### 操作数与寻址

操作数类型：

* 立即数：用\$表示，传送指令：movq \$0x4,%rax
* 寄存器：直接调用寄存器，传送指令：movq %rax,%rdx
* 存储器：使用括号将寄存器括起来表示值，传送指令：movq (%rax),%rdx

### 各类指令功能

> b：1； w：2； l：4； q：8；

#### 传送类指令

把数据从源位置复制到目的位置mov包括movb,movw,movl,movq

出栈入栈指令：堆栈也可以完成数据传送的工作，它是遵循先进后出规则的一个内存区域。它的地址向下增长，栈顶元素的地址最小

#### 运算类指令

| 描述         | 指令     | 效果         |
| ------------ | -------- | ------------ |
| 加载有效地址 | leaq S,D | D<--&S       |
| 加1          | INC D    | D<--D+1      |
| 减1          | DEC D    | D<--D-1      |
| 取负         | NEG D    | D<---D       |
| 取反         | NOT D    | D<--~D       |
| 加法         | ADD S,D  | D<--D+S      |
| 减法         | SUB S,D  | D<--D-s      |
| 乘法         | IMUL S,D | D<--D*S      |
| 异或         | XOR S,D  | D<--D^S      |
| 或           | OR S,D   | D<--D\|S     |
| 与           | AND S,D  | D<--D&S      |
| 算数左移     | SAL k,D  | D<--D<<k     |
| 逻辑左移     | SHL k,D  | D<--D<<k     |
| 算术右移     | SAR k,D  | D<--D$>>_A$k |
| 逻辑右移     | SHR k,D  | D<--D$>>_L$k |

加载有效地址：源操作数是地址表达式，但不直接引用内存，不敌操作数存放表达式形成的地址

一元操作：只有一个操作数，因此该数即是源操作数又是目的操作数，可以说寄存器也可以是内存地址

二元操作数：
第一个操作数是源操作数，可以是立即数、寄存器或者内存地址；
第二个操作数既是源操作数也是目的操作数， 可以是寄存器或者内存地址，但不能是立即数

移位操作：
左移指令SAL和SHL，二者的效果是一样的，都是在右边填零
右移指令包括算术右移和逻辑右移
算术右移算术右移需要填符号位
逻辑右移，逻辑右移需要填零

> 对于移位量k，可以是一个立即数，或者是放在寄存器cl中的数，对于移位指令只允许以特定的寄存器cl作为操作数，其他寄存器不行

#### 条件码

| 条件码 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| CF     | 进位标志,可以用来检查无符号数操作的溢出，产生进位置1         |
| ZF     | 零标志，当最近操作的结果等于零时,置1                         |
| SF     | 符号标志，当最近的操作结果小于零时，置1                      |
| OF     | 溢出标志，针对有符号数，最近的操作导致正溢出或者负溢出时，被置1 |

> Leaq对条件码不起作用

![](C:/Users/MaxBao/OneDrive/Markdown笔记/深入理解计算机/img/Set.png) 

#### 比较指令

| 描述 | 指令           | 基于         |
| ---- | -------------- | ------------ |
| 比较 | cmp $S_1,S_2$  | $S_2-S_1$    |
| 测试 | TEST $S_1,S_2$ | $S_1 \& S_2$ |

#### 跳转指令

将当前指令的执行从当前位置切换到新位置，可以直接进行或根据状态码状态

![](C:/Users/MaxBao/OneDrive/Markdown笔记/深入理解计算机/img/jmp.png)

#### 条件分支的实现

控制的条件转移：比较指令+跳转指令

数据的条件转移：

![](C:/Users/MaxBao/OneDrive/Markdown笔记/深入理解计算机/img/条件传说指令.png)

> 表达式的计算复杂度高时，不适合用条件传送

#### 循环

do-while

> 先执行do，在进行条件判断，满足则跳回goto循环起始位置

while

> 先跳，跳到条件判断，满足则再跳到do位置

for

> 将for的参数初始化在循环外赋值，限制条件放在while里，改写成while再进行

switch

> 先进性判断，然后跳转goto到对应的case中，否则跳转到default处，break即跳转到最后

#### 跳转表



### 过程



栈帧：

![](C:/Users/MaxBao/OneDrive/Markdown笔记/深入理解计算机/img/栈帧.png)

转移控制：函数P调用函数Q，把返回地址压入栈中，指明当函数Q执行结束返回时要从函数P的哪个位置继续执行，由call指令执行

Call指令：call label

* 返回地址压栈
* 跳转到label指示的地址

Ret指令：ret

* 弹出返回地址
* 转向返回地址

数据传递

> 如果一个函数的参数数量大于6，超出的部分就要通过栈来传递
>
> movq n*4(%rsp)，%rax

栈上的局部存储

> 当代码中对一个局部变量使用地址运算符‘&’时，需要在栈上为这个局部变量开辟相应的存储空间

寄存器的局部存储空间

当过程P调用Q时，P为调用者，Q为被调用者

调用者保存：调用者将临时值保存在自己的栈帧中
被调用者保存：被调用者在使用前将临时值保存在自己的栈帧中，返回时进行恢复

### 数组

数组T A\[L\]：

* 数据类型T和长度L
* 需要给数组分配连续空间大小为L*sizeof(T)字节
* 任何字节的指针都是8字节

嵌套数组T A\[R\]\[C\]：嵌套数组中行优先

* A是二维数组
* R是行数，C是列数
* T是A中元素的数据类型
* 数据连续空间大小为R\*C\*T字节
* 地址访问为：A+i\*(C\*T)+J\*T=A+(i\*C+j)\*K
  * 数组起始地址A，加上行起始地址，再加上列起始地址

定长数组和变长数组

### 结构体

结构：将不同类型的对象集中到一个对象中

结构体的所有组成部分存储在内存一段连续的区域中存放的顺序按照声明的顺序
指向结构体的指针是结构体第一个字节的地址

### 对齐

数据以数据类型的整数倍分配空间

结构体数据的对齐：

* 结构体内部：满足每个数据的对齐条件
* 整个结构体：结构体的对齐按照最长元素长度K来决定

### 缓冲区溢出

> 内存越界导致缓冲区溢出

解决溢出方法：

* 栈随机化：栈的位置在程序每次运行时都有变化
* 栈破坏检测：栈保护机制：在缓冲区与栈保存的状态值之间存储一个特殊值，这个特殊值被称作金丝雀值，这个数值是程序每次运行时随机产生的，在函数返回之前，检测金丝雀值是否被修改来判断是否遭受攻击
* 限制可执行代码区域
