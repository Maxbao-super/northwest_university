# 第二章

## 2.1 命题演算Propositional Calculus

命题演算的符号包括：

* 命题符号：P，Q，R，S...大写的字母等
* 真值符号：true，false
* 连接词：$\and,\or,\lnot,\to,\equiv$等

命题符号表示命题对世界的陈述，可能为真可能为假。

* 每个命题符号和真值符号都是一条语句

> 合法的语句被称为合式公式
>
> 合取项：$P\and Q$<br/>析取项：$P\or Q$<br/>非：$\lnot Q$<br/>蕴含：$P\to Q$(P是前提,Q是结论)<br/>等价：$P\and Q \equiv R$

等价公式

| 换质换位定律 | $(P\to Q)\equiv(\lnot Q \to \lnot P)$                        |
| ------------ | ------------------------------------------------------------ |
| 德摩根定律   | $\lnot(P\or Q)\equiv(\lnot P \and \lnot Q)$；$\lnot(P\and Q)\equiv(\lnot P \or \lnot Q)$ |
| 交换律       | $(P\and Q)\equiv(Q\and P)$；$(P\or Q)\equiv(Q\or P)$         |
| 结合律       | $((P\and Q)\and R)\equiv(P\and(Q\and R))$；$((P\or Q)\or R)\equiv(P\or (Q\or R))$ |
| 分配律       | $P\and(Q\or R)\equiv(P\or Q)\and(P\or R)$；$P\or(Q\and R)\equiv(P\and Q)\or(P\and R)$ |

## 2.2 谓词演算Predicate Calculus

谓词演算符号：用以构成谓词演算符号的字符表：

* 真值符号：true false
* 常量符号constant：小写字母开头的符号表达式
* 变量符号variable：大写字母开头的符号表达式
* 函数符号function：小写字母开头的符号表达式，且具有附带的元数用以指出被映射到值域的元素的定义域的元素个数

原子语句 （原子表达式、原子或命题）：谓词演算语言中的最基本单位，式元数为n的谓词，后用括号为包围且逗号分隔的n个参数项

谓词演算语句（=连结符+原子语句）：每一条原子语句都是一条谓词演算语句

## 2.3.1 推理规则

* 满足：在解释下一个特定的变量赋值使表达式为真，则解释满足表达式，只允许一种解释
* 模型：对所有的变量赋值来说都满足表达式，则说解释是表达式的模型
* 有效：对所有可能的解释来说表达式的值都是真，则表达式有效
* 不一致：表达式集合不可满足

逻辑派生：满足表达式集合S的所有解释也满足另一个表达式X，则X逻辑派生自S

可靠：表达式集合S产生的所有表达式也派生自表达式集合S，则推理规则可靠

完备：表达式集合S，一个规则可以推理出逻辑派生自S的所有表达式，则推理规则完备

* 拒式假言推理
* 取式假言推理
* 与消除
* 与引入
* 全称例化

## 2.3.2 合一

合一：判断什么样的替换可以产生的两个谓词演算表达式的算法

替换：f(X)-->f(a)就是把X替换为a

> 斯科伦化skolemization：把每个存在量化变量用一个函数替换

> 常量不可被替换

复合：两个替换集合进行复核，其中一个集合的元素应用到另一个集合上，再把结果加到本身

**最一般合一most general unifier**：如果s是表达式E的任意一个合一式，g式这个表达式最一般合一式，则应用到E的s，存在另一个合一式s'使Es=Egs'，期中Es和Egs'是应用到表达式E的合一式的复合

**合一树图示**

# 第三章

## 3.1 图搜索结构与技术

### 状态图搜索

* 图是结点(状态)的集合和连接这些节点的弧的集合。
* 带标签的图：用一个或多个标签附加在每个结点上
* 弧也可以有标签：
  * 说明弧代表的是一种命名关系
  * 把权值附加在弧上
* 有向图：弧具有方向性，具有两个方向的弧可以带两个箭头
* 路径：通过多个相继的弧把一系列结点连接起来，可以用有序链表表示
* 有根图：具有一个特殊的结点，这个结点到任意一个结点都有一条路径
* 树：两个结点之间至多有一条路径的图

有限状态图：

状态转换表：





### 与或树





### 博弈树



## 3.2 搜索策略

### 数据驱动

也称正向追索，问题求解器从问题的给定事实和改变状态的合法移动或规则的集合入手。把规则应用到事实产生新的事实，以此下推，直到产生满足目标条件的一条路径。

> 从问题的事实入手，应用规则或合法移动产生通往目标的新的事实

适合问题：

* 问题的初始陈述给出了所有或大部分数据
* 潜在目标的数量非常庞大，但使用特定问题实例的给定信息和事实的方式很有限
* 难以组成目标或假设

### 目标驱动

从想要求解的目标入手，先分析怎样使用规划或合法移动来产生这个目标并求出想要应用这些规则或移动必须具有的条件。条件则成为新的要搜索的目标或者称为子目标，然后反向追溯相继的子目标，直到返回到问题中的事实。

> 把焦点集中再目标上，寻找可以产生这个目标的规则，并环环相扣地反向追索相继的规则和子目标直到到达问题的给定事实

适合问题：

* 目标或假设再问题陈述中已经给出，或很容易形式化
* 与问题事实匹配的规则数量非常多，产生的结论或目标越来越多
* 问题数据不是给定的，要由问题求解器来获取

### 宽度优先搜索

一层一层地搜索空间，只有给定层上不存在要检索的状态时才转移到下一层

尝试用open和closed跟踪穿越空间的过程：

* open视为队列，先入先出，后继状态从右端插入

> 可以找到从起始结点到目标结点的最短路径

### 深度优先搜索

尽可能的向搜索空间的更深层前进，只有找不到状态的后代才会考虑他的兄弟

* open被视作堆栈，先入后出，后继状态从左端插入

**迭代加深的深度优先**



## 3.3 实例应用

### 逻辑系统的状态空间

### 八数码

### 一字棋

### TSP旅行商问题

# 第四章

采用启发式的情况：

* 在问题陈述或现有数据中存在固有的模糊性，所以问题可能没有精确解
* 问题可能有精确解，但是找到这个解的运算开销可能让人难以接受

启发式搜索-->启发度量+使用度量进行空间搜索的算法

## 4.2 最好优先算法

具有更好的灵活性，使用优先级队列。

> 用列表维护状态：<br/>open记录搜索的当前搜索带<br/>closed列表记录已经访问过的状态<br/>新增：对open中的状态进行排序，依据是状态与目标的接近程度的某种启发性估计
>
> 把open维护成为有序列表，因此常称为优先级队列

启发估价函数：F(n)=g(n)+h(n)

* g(n)是从任意状态n到起始状态的实际路径长度
* h(n)是对状态n到目标的距离的启发性估计

## 4.3.1 可采纳性admissibility

只要存在到达一个目标的最短路径，启发就可以找到这条最短路径，则启发可采纳

A算法：

> 考虑估价函数 f(n)=g(n)+h(n)
>
> n是搜索中遇到的任意状态<br/>g(n)是从起始状态到n的代价<br/>h(n)是对n到目标状态代价的启发式设计

$A^*$算法：

> A算法中使用的估价函数满足 ::: $h(n) \le n到目标的最短路径代价$

特点：所有的$A^*$算法都是可采纳的

## 4.3.2 单调性monotonicity

是否存在“局部可采纳”的启发，即是否总是可以找到到达搜索中遇到的每个状态的最短路径

> 启发函数h单调的条件：
>
> * 对于所有状态$n_i和n_j$,其中$n_j是n_i$的后继
> * 目标状态的启发值为零,即h(Goal)=0

**启发的可采纳性是否包含了单调性?**

## 4.3.3 信息度Informedness

> 对于两个$A_*$启发$h_1和h_2$，如果对搜索空间中的所有状态n都满足$h_1(n)\le h_2(n)$，就说明$h_2比h_1具有更高的信息都



## 4.4.1 极小极大过程

基于假定(假定对手具有相同的关于状态空间的知识，也应用这一知识以一致的方式赢得比赛)

极大极小搜索根据规则沿连续的父节点向上传播值：

* 父节点状态是MAX结点，则把孩子的最大值赋值给他
* 父节点状态是MIN结点，把孩子的最小值赋值给他

## 4.4.2 n层预判-固定层深的极小极大过程

> 由于子图的节点不是最终状态，所以需要根据某个启发评估函数给每个节点赋值，向上传播的值并不表示是否可以胜利，只代表从当前起始节点通过n次移动可以达到的最佳状态的启发值

需要对搜索空间进行两遍分析

1. 向下降到预判层并在那里应用启发评估
2. 沿树向上传播评估值

## 4.4.3 $\alpha-\beta $过程

提高双人博弈的搜索效率

> 不搜索预判深度的整个空间，而是以深度优先的方式前进，产生两个值为$\alpha 和\beta$，$\alpha$与MAX结点的关联从不减小，$\beta$与MIN结点相关联从不增大
>
> $\alpha$是下界，$\beta$是上界
>
> 即：
>
> * MAX结点下，发现一个$\alpha$值大于或等于任意一个MIN祖先结点的$\beta$值，就终止搜索
> * MIN结点下，发现一个$\beta$值小于或等于任意一个MAN祖先结点的$\alpha$值，就终止搜索

# 第六章

## 递归Recursion Search

> 递归步骤：过程调用自身完成一系列动作
>
> 使递归过程从无限递归中停止的条件

### 模式驱动Module Driver





## 产生式系统production system

> 为控制问题求解过程提供了一种面向模式的手段

产生式系统的构成：

* 产生式规则集合the set of production rules：产生式就是一个“条件-动作”对，定义了求解问题的一个知识块。
  * **条件部分**是一种模式，用来确定何时可以把这个规则应用到问题实例上
  * **动作部分**：定义相关联的求解问题步骤
* 工作内存working memory：包含了推理过程中对世界当前状态的描述
* 识别-动作循环the recognize-act cycle：
  * 先使用问题描述初始化工作内存，并把求解问题的当前状态维护为工作内存中的模式集合；
  * 再把这些模式与产生式规则的条件进行匹配；
  * 条件和工作内存中的模式相匹配的规则形成一个子集，称为**冲突集合**
  * 冲突集合中选择一个产生式(称为使能的)，并激发它（激发一个规则就是执行他的动作）；激发后对修改的工作内存重复这个控制循环，直到内存内容没有和规则匹配的内容
* 冲突消解conflict resolution：从冲突集合中选取一个要激发的规则

> 纯粹的产生式模型不包含任何从搜索死端恢复的机制，只是不断执行识别-动作循环直到不再有任何已经使能的产生式便停止

产生式系统示意图：![](img\产生式系统.png)

产生式执行过程：![](img\产生式执行过程.png)



Production Rules：if...then...  P->Q



## 搜索控制

### 数据驱动搜索

从问题的描述开始，从数据中推理出新知识

> 首先都世界的当前描述应用推理规则，在博弈中选取合法移动
> 或应用其他的“状态产生”操作，把得到的结果加入到问题的描述中

### 目标驱动控制搜索



### 规则结构控制搜索



### 冲突消解控制搜索
