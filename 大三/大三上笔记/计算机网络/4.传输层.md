# 传输层(Transport Layer)

![传输层导图](img\传输层导图.jpeg)

## 概述

传输层也翻译为运输层，为网络层提供通信服务，使用网络层的服务

功能：

* 传输层提供进程和进程之间的逻辑通信，端到端
* 复用和分用
  * 复用：应用层所有的应用进程都可以通过传输层再传输到网络层
  * 分用：传输层从网络层收到数据后交付指明的应用进程
* 对收到的报文进行差错检测

### 端口

端口是传输层的SAP，表示主机中的应用进程

端口号只有本地意义，在因特网中不同计算机的相同端口没有联系，长度16bit，可表示65536个不同端口号

端口号

* 服务端使用
  * 熟知端口号：给TCP/IP最重要的一些应用，所有用户都知道，0~1023
  * 登记端口号：为没有熟知端口号的应用程序使用，1024~49151
* 客户端使用：仅在客户进程运行时才动态选择的端口号，49152~65536

常用端口：

### 可靠性

* 端到端连接管理
  * 端标示
  * 建立连接
  * 数据传输
  * 释放连接
* 流量控制
* 拥塞控制
* 差错控制
* 端到端顺序控制，差错检测及恢复
* 分段处理及QoS监测，崩溃恢复

### 网络应用框架：客户端/服务器模式

### 网络编程接口：socket API

## UDP协议

无连接的用户数据报协议，只在IP数据报服务上增加了复用分用和差错检测功能

> 传送数据前不需要建立连接，收到UDP报文后也不需要给出确认

特点：不可靠、无连接、时延小，适用于小文件

* 无连接，减少开销和发送数据之前的时延
* 使用最大努力交付，不保证可靠交付
* 面向报文，适合一次性传输少量数据的网络应用
* 无拥塞控制，适合很多实时应用
* 首部开销小，8B，对比于TCP的20B

### 首部格式

![](img\UDP首部.png)

分用时，找不到对应的目的端口，就丢弃报文，并给发送方发送ICMP“端口不可达”差错报告报文

### UDP校验

在数据报中添加伪首部，但只有在计算检验和时才出现，不向下传送也不向上提交

![](img\UDP校验.png)

* 17：封装的UDP报文的IP数据报首部协议字段是17
* UDP长度：UDP首部8B+数据部分长度（不包括伪首部）

检验和使用16bit段反码运算，按二进制反码运算求和，并<span style="color:red">将结果取反</span>

![](img\UDP检验和.png)

在发送端：

1. 填上伪首部
2. 全0填充检验和字段
3. 全0填充数据部分(UDP数据报要看成许多4B的字串接起来）
4. 伪首部+首部+数据部分采用二进制反码求和
5. 把和求反码填入检验和字段
6. 去掉伪首部，发送

在接收端：

1. 填上伪首部
2. 伪首部+首部+数据部分采用二进制反码求和
3. 结果全为1则无差错,否则丢弃数据报/交给应用层附上出差错的警告。

## TCP协议

面向连接的传输控制协议

> 传送数据之前必须建立连接，数据发送结束后释放连接，不提供广播或多播服务

特点：

* 可靠交付服务、面向连接、时延大，无差错、不丢失、不重复、按序到达，适用于大文件
* 每条TCP只能有两个端点，即点对点连接
* 提供全双工通信
  * 发送缓存：准备发送的顺序和已发送但尚未收到确认的数据
  * 接收缓存：按序到达但未被接受应用程序读取的数据和不按序到达的数据
* 面向字节流：把应用程序交下来的数据看作一串无结构字节流

### 首部格式

![](img\TCPhead.png)

* 序号：TCP连接中传送的字节流每个字节都按序编号，表示本报文段所发送数据的第一个字节的序号
* 确认号：期望收到对方下个报文段的第一个数据字节的序号
* 数据偏移：首部长度，报文段的数据起始处距离报文段的起始处的距离，以4B为单位
* 保留位：
  * URG：紧急位，表明此处报文段有紧急数据，优先级最高的数据，应尽快传送，不用缓存配对，配合紧急指针字段使用
  * ACK：确认位，为1时确认号有效，建立连接后所发送的报文的必须ACK为1
  * PSH：推送位，为1时接收方尽快交付接收应用进程，不得等到缓存队列满了再向上交付
  * RST：复位，为1时表明TCP连接出现差错，必须释放连接重新建立
  * SYN：同步位，表明一个连接请求或连接接收报文
  * FIN：终止位，表明此报文段发送数据已经完成，请求释放连接
* 窗口：发送本报文段的一方的接收窗口，即现在允许对方发送的数据量
* 检验和：检验首部+数据，检验时要加上12B伪首部，第四个字段为6
* 紧急指针：URG=1时才有意义，指出本报文段中紧急数据的字节数
* 选项：最大报文段长度MSS、窗口扩大、时间戳、选择确认

### TCP连接管理

TCP连接传输三个阶段：

1. 连接建立
2. 数据传送
3. 连接释放

> 建议采用CS方式，主动发起建立的应用进程叫客户，被动等待连接的应用进程叫服务器

![](img\TCPconnect.png)

SYN洪范攻击

> SYN洪泛攻击发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。
> 攻击者发送SYN，SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者
> <span style="color:red">这样更加会浪费服务器的资源</span>
> 攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了

连接释放：

![](img\TCPrelease.png)

### 可靠传输

可靠：保证接收方进程从缓存读出的字节流与发送方发出的字节流完全一样

> 传输层：TCP实现可靠传输
> 网络层：尽最大努力交付，不可靠传输

机制：

1. 校验：和UDP校验一样增加伪首部
2. 序号：一个字节占用一个序号
3. 确认：首部确认字段为4，TCP默认使用累积确认
4. 重传：在规定时间内没有收到确认就要重新发送已发送的信息--超时重传
   1. 重传时间采用自适应算法，动态改变重传时间RTT（加权往返时间）
   2. 冗余ACK：每当比期望序号大的失序报文段到达时，发送一个冗余ACK，知名下一个期待字节的序号

### 流量控制

流量控制：让发送方慢点，让接收方有时间进行接收

利用“滑动窗口”实现

> 通信过程中接收方根据自己接收缓存的大小，动态调整发送方的发送窗口大小，即接收窗口rwnd。发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值

![](img\FlowControl.png)

> TCP为每一个连接设有一个持续计时器,只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。
> 若持续计时器设置的时间到期，就发送一个零窗口探测报文段。接收方收到探测报文段时给出现在的窗口值。
> 若窗口仍然是0,那么发送方就重新设置持续计时器。

### 拥塞控制

拥塞：大多信号源以太快速度发送数据，对资源需求的综合大于可用资源

> 资源同时呈现供应不足--网络性能变坏--网络吞吐量将随输入负荷增大而下降

拥塞控制：防止过多的数据注入网络中，全局性

### 拥塞控制算法

假定：
1.数据单方向传送,而另一个方向只传送确认
2.接收方总是有足够大的缓存空间，因而发送窗口大小取决于拥塞程度
发送窗口=Min{接收窗口rwnd，拥塞窗口cwnd}

接收窗口：接收方根据接受缓存设置的值，并告知给发送方，反映接收方容量

拥塞窗口：发送方根据自己估算的网络拥塞程度而设置的窗口值,反映网络当前容量

#### 慢开始

cwnd=1，每轮次指数增长

慢开始门限：ssthresh，增长到限制就使用拥塞控制--加法增大

出现拥塞：

* cwnd=1
* ssthresh是拥塞时cwnd的一半

#### 拥塞避免

加法增大

* 加一加一

乘法减小

* ssthresh是拥塞时cwnd的一半

#### 快重传

收到三个冗余的重复确认就执行快重传算法

#### 快恢复

收到三个冗余的重复确认将cwnd降到新的门限值
